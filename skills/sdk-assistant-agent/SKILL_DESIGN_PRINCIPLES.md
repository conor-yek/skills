# Skill 设计原则

> 本文件定义 sdk-assistant-agent 体系中所有 skill 的设计规范。
> **编写新 skill 或迭代现有 skill 前必须遵循本原则。**

---

## 核心认知：Skill 是给 LLM 执行的程序，不是给人读的文档

这是一切原则的出发点。Skill 文件的读者是 LLM，不是人类开发者。
这意味着：写 skill 的方式更接近写代码，而不是写说明书。

---

## 原则一：指令必须可执行，映射到具体工具调用

**反模式（人类文档写法）：**
> "在生成代码前，参考现有的类似驱动"

**正确写法（LLM 程序写法）：**
> `Glob drivers/lisa_gpio/**` → 读取 `.h` 文件 → 提取 vtable 结构 → 作为生成模板

每一步要明确：**用哪个工具、传什么参数、从结果中提取什么**。

---

## 原则二：用活的数据源替代静态知识

Skill 文件中的静态 API 说明会过时，且占用宝贵的上下文窗口。

**正确做法：**
- API 细节 → 指令 `WebFetch [online-docs.md 中对应的 URL]`
- 实现模式 → 指令 `Glob/Grep codebase 中的现有实现`
- 配置选项 → 指令 `Read 对应的 Kconfig 文件`

**规则：** Skill 文件只记录"去哪里找"，不记录"找到的内容是什么"。
知识文件（`knowledge/*.md`）记录经过验证的稳定知识，但 Skill 文件本身不内嵌 API。

---

## 原则三：决策树替代散文指引

**反模式：**
> "根据设备类型选择合适的参考实现"

**正确写法：**
```
IF 传感器类  → Glob drivers/lisa_adc/**
IF 通信接口  → Glob drivers/lisa_uart/** 或 drivers/lisa_spi/**
IF 存储设备  → Glob drivers/lisa_flash/**
IF 显示设备  → Glob drivers/lisa_display/**
ELSE         → 向用户确认设备类型
```

分支条件要具体、互斥、可判断。

---

## 原则四：Token 效率 — 密度优于完整性

Skill 文件每次调用都会加载到上下文，每个多余的词都有代价。

**实践规则：**
- 用表格代替列表，用列表代替段落
- 删除所有对 LLM 执行没有影响的解释性文字
- checklist 项只写**可验证的条件**，不写无法判断的"应该"
- 子 skill 的 SKILL.md 不重复父级已有的通用知识

---

## 原则五：质量检查项必须可机器判断

**反模式：**
> "- [ ] 代码风格符合规范"

**正确写法：**
> "- [ ] 每个 vtable 函数都有对应的 `static inline` 包装，包装内含 `!dev || !dev->api` NULL 检查"
> "- [ ] `Kconfig` 中存在 `depends on LISA_DEVICE` 行"
> "- [ ] `CMakeLists.txt` 中使用 `listenai_library_sources_ifdef` 而非原生 `target_sources`"

每条 checklist 项要能通过读文件或 Grep 来确认。

---

## 原则六：明确定义"何时询问用户"

Skill 应该明确指定两种情况的边界：

- **可以推断，直接执行**：用户提到了设备名称，可以直接 Glob 对应驱动目录
- **必须询问，不得猜测**：引脚号、设备名、中断优先级等参数缺失时

不要让 LLM 自由发挥猜测关键参数。

---

## 原则七：行为与知识分离

| 文件类型 | 存放内容 | 举例 |
|----------|----------|------|
| `SKILL.md` | 执行指令、决策树、工具调用步骤 | "Step 1: Glob... Step 2: WebFetch..." |
| `knowledge/*.md` | 经过验证的稳定参考知识 | 错误码表、已知构建问题模式 |
| `online-docs.md` | URL 映射表 | 各驱动/组件的文档地址 |

**规则：** SKILL.md 引用知识文件，不内嵌知识内容。

---

## 原则八：子 Skill 的调用协议

父级 SKILL.md 通过 "读取 `xxx/SKILL.md` 执行" 调用子 skill。
子 skill 必须满足：

1. **自包含**：执行所需的上下文来源于工具调用，不依赖父级传递的隐式状态
2. **单一职责**：一个子 skill 解决一类问题，不承担路由职责
3. **输出明确**：结尾声明产出物（生成了哪些文件、回答了什么问题）

---

## 原则九：迭代友好的结构

Skill 文件应便于局部更新：
- 每个 Step 是独立的逻辑单元，修改一个 Step 不影响其他 Step
- 决策树的分支条件写在同一处，不散落在多个地方
- 新增功能通过新增 Step 或新增分支，而非修改现有逻辑

---

## 自检清单（编写/修改 skill 后使用）

在提交 skill 变更前，逐项确认：

- [ ] 每个 Step 都包含至少一个具体工具调用（非仅文字描述）
- [ ] 没有内嵌可以通过 WebFetch/Grep 获取的 API 信息
- [ ] 所有决策分支的判断条件是明确的
- [ ] 所有质量 checklist 项都可以通过读文件来验证
- [ ] "何时询问用户"的边界是明确的
- [ ] 文件中没有纯解释性的段落（对 LLM 执行无影响的内容）
- [ ] 子 skill 不依赖父级的隐式状态
